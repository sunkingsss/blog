### 栈空间

> 由系统自行管理

### 堆内存：

代际假说：

-   1.大部分对象在内存中存活时间很短
-   2.不死的对象会活的更久,比如全局 window，dom，全局 api 等对象

判断活动对象：

> 将一个称为 GC Roots 的对象（在浏览器环境中，GC Roots 可以包括：全局的 window 对象、所有原生 dom 节点集合等等）作为所有初始存活的对象集合，从这个对象出发，进行遍历，遍历到的就认为是可访问的，为活动对象，需要保留；如果没有遍历到的对象，就是不可访问的，这些就是非活动对象，可能就会被垃圾回收。

划分：

> 1.新生代：新分配的对象会放入新生代中

    -   1.1 from space
    -   1.2 to space

> 2.老生代：通过 v8 的晋升机制将新生代中的对象在满足一定条件下放入老生代中

Scavenger 算法：主要用于管理新生代堆内存

> 新分配的对象放入新生代的 from space 内存中
> 当 from space 内存空间达到上限时，会对 from space 内存进行整理，将活动对象拷贝至 to space 空间内，然后清除 from space 空间内的非活动对象
> 将 from space 和 to space 进行角色互换

Mark-Sweep & Mark-Compact 算法：主要用于老生代的内存管理

> 标记-清除过程：与之前讲过的可访问性分析一致，从 GC Root 开始遍历，标记完成后，就直接进行垃圾数据的清理工作。
> 标记-整理过程：清除算法后会产生大量不连续的内存碎片，碎片过多会导致后面大对象无法分配到足够的空间，所以需要进行整理，第一步的标记是一样的，但标记完成活跃对象后，并不是进行清理，而是将所有存活的对象向一端移动，然后清理掉这端之外的内存。

新生代晋升老生代规则：

> 经历一次 Scavenger 算法后，仍未被标记清除的对象
> 进行复制的对象大于 to space 空间大小的 25%

优化：

> 原因：由于 js 是单线程，定期进行 gc 会导致主线程卡顿
> 手段：

    1.并行回收: 开启多个辅助线程，新生代使用的就是并行策略
    2.增量回收：Orinoco将标记工作分解成小块，插在主线程不同的任务之间执行
    3.三色标记法：
        3.1 最开始所有对象都是白色状态
        3.2 从GC Root遍历所有可到达的对象，标记为灰色，放入待处理队列
        3.3 从待处理队列中取出灰色对象，将其引用的对象标记为灰色放入待处理队列，自身标记为黑色
        3.4 重复3中动作，直到灰色对象队列为空，此时白色对象就是垃圾，进行回收。
    3.写屏障：一旦有黑色对象引用到了白色对象，系统会强制将白色对象标记成为灰色对象，从而保证了下次gc执行时状态的正确
